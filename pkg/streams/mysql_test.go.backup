package streams

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"github.com/cohenjo/replicator/pkg/config"
	"github.com/cohenjo/replicator/pkg/events"
	"github.com/go-mysql-org/go-mysql/canal"
	"github.com/go-mysql-org/go-mysql/mysql"
	"github.com/go-mysql-org/go-mysql/replication"
	"github.com/go-mysql-org/go-mysql/schema"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// MockEventSender captures events for testing
type MockEventSender struct {
	events []events.RecordEvent
	ch     chan events.RecordEvent
}

// NewMockEventSender creates a new mock event sender
func NewMockEventSender() *MockEventSender {
	m := &MockEventSender{
		events: make([]events.RecordEvent, 0),
		ch:     make(chan events.RecordEvent, 100),
	}
	
	// Start goroutine to capture events
	go func() {
		for event := range m.ch {
			m.events = append(m.events, event)
		}
	}()
	
	return m
}

// GetChannel returns the channel for sending events
func (m *MockEventSender) GetChannel() chan<- events.RecordEvent {
	return m.ch
}

// GetEvents returns captured events
func (m *MockEventSender) GetEvents() []events.RecordEvent {
	return m.events
}

// WaitForEvents waits for specified number of events with timeout
func (m *MockEventSender) WaitForEvents(count int, timeout time.Duration) bool {
	deadline := time.Now().Add(timeout)
	for time.Now().Before(deadline) {
		if len(m.events) >= count {
			return true
		}
		time.Sleep(10 * time.Millisecond)
	}
	return false
}

// Close closes the event channel
func (m *MockEventSender) Close() {
	close(m.ch)
}

func TestNewMySQLStreamProvider(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	logger.SetLevel(logrus.DebugLevel)
	
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	
	assert.NotNil(t, provider)
	assert.Equal(t, "mysql", provider.StreamType())
	assert.NotNil(t, provider.eventSender)
	assert.NotNil(t, provider.logger)
	assert.NotNil(t, provider.stopChannel)
	assert.False(t, provider.isRunning)
	assert.Equal(t, 1*time.Second, provider.pollInterval)
	assert.Equal(t, 2.0, provider.backoffFactor)
	assert.Equal(t, 5*time.Minute, provider.maxBackoff)
	assert.Equal(t, 10, provider.maxRetries)
}

func TestMySQLStreamProvider_ParseConfig(t *testing.T) {
	tests := []struct {
		name        string
		setupConfig func()
		expectError bool
		expected    *MySQLConfig
	}{
		{
			name: "valid config from WaterFlowsConfig",
			setupConfig: func() {
				config.Global = &config.Config{
					MyDBUser:    "testuser",
					MyDBPasswd:  "testpass",
					WaterFlowsConfig: &config.WaterFlowsConfig{
						Type:   "mysql",
						Host:   "localhost",
						Port:   3306,
						Schema: "testdb",
						MySQLServerID:        1234,
						MySQLBinlogFile:      "mysql-bin.000001",
						MySQLBinlogPosition:  "1000",
						MySQLIncludeTables:   []string{"users", "orders"},
						MySQLExcludeTables:   []string{"logs"},
						MySQLIncludeOperations: []string{"insert", "update"},
						MySQLExcludeOperations: []string{"delete"},
					},
				}
			},
			expectError: false,
			expected: &MySQLConfig{
				Host:              "localhost",
				Port:              3306,
				Username:          "testuser",
				Password:          "testpass",
				Database:          "testdb",
				ServerID:          1234,
				BinlogFile:        "mysql-bin.000001",
				BinlogPosition:    "1000",
				IncludeTables:     []string{"users", "orders"},
				ExcludeTables:     []string{"logs"},
				IncludeOperations: []string{"insert", "update"},
				ExcludeOperations: []string{"delete"},
			},
		},
		{
			name: "missing host",
			setupConfig: func() {
				config.Global = &config.Config{
					MyDBUser:   "testuser",
					MyDBPasswd: "testpass",
					WaterFlowsConfig: &config.WaterFlowsConfig{
						Type:   "mysql",
						Schema: "testdb",
					},
				}
			},
			expectError: true,
		},
		{
			name: "missing database",
			setupConfig: func() {
				config.Global = &config.Config{
					MyDBUser:   "testuser",
					MyDBPasswd: "testpass",
					WaterFlowsConfig: &config.WaterFlowsConfig{
						Type: "mysql",
						Host: "localhost",
						Port: 3306,
					},
				}
			},
			expectError: true,
		},
		{
			name: "missing username",
			setupConfig: func() {
				config.Global = &config.Config{
					MyDBPasswd: "testpass",
					WaterFlowsConfig: &config.WaterFlowsConfig{
						Type:   "mysql",
						Host:   "localhost",
						Port:   3306,
						Schema: "testdb",
					},
				}
			},
			expectError: true,
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			tt.setupConfig()
			
			mockSender := NewMockEventSender()
			defer mockSender.Close()
			
			logger := logrus.New()
			provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
			
			// Test
			err := provider.parseMySQLConfig()
			
			// Verify
			if tt.expectError {
				assert.Error(t, err)
				return
			}
			
			require.NoError(t, err)
			assert.Equal(t, tt.expected.Host, provider.config.Host)
			assert.Equal(t, tt.expected.Port, provider.config.Port)
			assert.Equal(t, tt.expected.Username, provider.config.Username)
			assert.Equal(t, tt.expected.Password, provider.config.Password)
			assert.Equal(t, tt.expected.Database, provider.config.Database)
			
			if tt.expected.ServerID != 0 {
				assert.Equal(t, tt.expected.ServerID, provider.config.ServerID)
			}
			if tt.expected.BinlogFile != "" {
				assert.Equal(t, tt.expected.BinlogFile, provider.config.BinlogFile)
			}
			if tt.expected.BinlogPosition != "" {
				assert.Equal(t, tt.expected.BinlogPosition, provider.config.BinlogPosition)
			}
			if len(tt.expected.IncludeTables) > 0 {
				assert.Equal(t, tt.expected.IncludeTables, provider.config.IncludeTables)
			}
			if len(tt.expected.ExcludeTables) > 0 {
				assert.Equal(t, tt.expected.ExcludeTables, provider.config.ExcludeTables)
			}
			if len(tt.expected.IncludeOperations) > 0 {
				assert.Equal(t, tt.expected.IncludeOperations, provider.config.IncludeOperations)
			}
			if len(tt.expected.ExcludeOperations) > 0 {
				assert.Equal(t, tt.expected.ExcludeOperations, provider.config.ExcludeOperations)
			}
		})
	}
}

func TestMySQLStreamProvider_TableFiltering(t *testing.T) {
	tests := []struct {
		name           string
		includeTables  []string
		excludeTables  []string
		schema         string
		table          string
		shouldFilter   bool
	}{
		{
			name:         "no filters - should not filter",
			schema:       "testdb",
			table:        "users",
			shouldFilter: false,
		},
		{
			name:          "include filter - table included",
			includeTables: []string{"users", "orders"},
			schema:        "testdb",
			table:         "users",
			shouldFilter:  false,
		},
		{
			name:          "include filter - table not included",
			includeTables: []string{"users", "orders"},
			schema:        "testdb",
			table:         "logs",
			shouldFilter:  true,
		},
		{
			name:          "include filter - full table name included",
			includeTables: []string{"testdb.users"},
			schema:        "testdb",
			table:         "users",
			shouldFilter:  false,
		},
		{
			name:          "exclude filter - table excluded",
			excludeTables: []string{"logs", "temp"},
			schema:        "testdb",
			table:         "logs",
			shouldFilter:  true,
		},
		{
			name:          "exclude filter - table not excluded",
			excludeTables: []string{"logs", "temp"},
			schema:        "testdb",
			table:         "users",
			shouldFilter:  false,
		},
		{
			name:          "both filters - included and not excluded",
			includeTables: []string{"users", "orders"},
			excludeTables: []string{"logs"},
			schema:        "testdb",
			table:         "users",
			shouldFilter:  false,
		},
		{
			name:          "both filters - included but excluded",
			includeTables: []string{"users", "orders"},
			excludeTables: []string{"users"},
			schema:        "testdb",
			table:         "users",
			shouldFilter:  true,
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockSender := NewMockEventSender()
			defer mockSender.Close()
			
			logger := logrus.New()
			provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
			
			provider.config = &MySQLConfig{
				IncludeTables: tt.includeTables,
				ExcludeTables: tt.excludeTables,
			}
			
			result := provider.shouldFilterTable(tt.schema, tt.table)
			assert.Equal(t, tt.shouldFilter, result)
		})
	}
}

func TestMySQLStreamProvider_OperationFiltering(t *testing.T) {
	tests := []struct {
		name              string
		includeOperations []string
		excludeOperations []string
		operation         string
		shouldFilter      bool
	}{
		{
			name:         "no filters - should not filter",
			operation:    "insert",
			shouldFilter: false,
		},
		{
			name:              "include filter - operation included",
			includeOperations: []string{"insert", "update"},
			operation:         "insert",
			shouldFilter:      false,
		},
		{
			name:              "include filter - operation not included",
			includeOperations: []string{"insert", "update"},
			operation:         "delete",
			shouldFilter:      true,
		},
		{
			name:              "exclude filter - operation excluded",
			excludeOperations: []string{"delete"},
			operation:         "delete",
			shouldFilter:      true,
		},
		{
			name:              "exclude filter - operation not excluded",
			excludeOperations: []string{"delete"},
			operation:         "insert",
			shouldFilter:      false,
		},
		{
			name:              "both filters - included and not excluded",
			includeOperations: []string{"insert", "update"},
			excludeOperations: []string{"delete"},
			operation:         "insert",
			shouldFilter:      false,
		},
		{
			name:              "both filters - included but excluded",
			includeOperations: []string{"insert", "update", "delete"},
			excludeOperations: []string{"delete"},
			operation:         "delete",
			shouldFilter:      true,
		},
		{
			name:              "case insensitive - INSERT vs insert",
			includeOperations: []string{"INSERT", "UPDATE"},
			operation:         "insert",
			shouldFilter:      false,
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockSender := NewMockEventSender()
			defer mockSender.Close()
			
			logger := logrus.New()
			provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
			
			provider.config = &MySQLConfig{
				IncludeOperations: tt.includeOperations,
				ExcludeOperations: tt.excludeOperations,
			}
			
			result := provider.shouldFilterOperation(tt.operation)
			assert.Equal(t, tt.shouldFilter, result)
		})
	}
}

func TestMySQLStreamProvider_IsFatalError(t *testing.T) {
	tests := []struct {
		name     string
		errorMsg string
		isFatal  bool
	}{
		{
			name:     "nil error",
			errorMsg: "",
			isFatal:  false,
		},
		{
			name:     "access denied error",
			errorMsg: "access denied for user 'test'@'localhost'",
			isFatal:  true,
		},
		{
			name:     "unknown database error",
			errorMsg: "unknown database 'nonexistent'",
			isFatal:  true,
		},
		{
			name:     "connection timeout error",
			errorMsg: "connection timeout",
			isFatal:  false,
		},
		{
			name:     "network error",
			errorMsg: "network unreachable",
			isFatal:  false,
		},
		{
			name:     "deadlock error",
			errorMsg: "deadlock found when trying to get lock",
			isFatal:  false,
		},
		{
			name:     "server has gone away",
			errorMsg: "MySQL server has gone away",
			isFatal:  true,
		},
		{
			name:     "unknown error",
			errorMsg: "some random error",
			isFatal:  false,
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockSender := NewMockEventSender()
			defer mockSender.Close()
			
			logger := logrus.New()
			provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
			
			var err error
			if tt.errorMsg != "" {
				err = &testError{msg: tt.errorMsg}
			}
			
			result := provider.isFatalError(err)
			assert.Equal(t, tt.isFatal, result)
		})
	}
}

// testError implements error interface for testing
type testError struct {
	msg string
}

func (e *testError) Error() string {
	return e.msg
}

func TestMySQLEventHandler_OnRow(t *testing.T) {
	// Setup
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	logger.SetLevel(logrus.DebugLevel)
	
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	provider.config = &MySQLConfig{
		Host:     "localhost",
		Port:     3306,
		Database: "testdb",
		Username: "test",
		Password: "test",
	}
	
	handler := &MySQLEventHandler{provider: provider}
	
	// Create mock table schema
	columns := []schema.TableColumn{
		{Name: "id"},
		{Name: "name"},
		{Name: "email"},
	}
	
	table := &schema.Table{
		Schema:  "testdb",
		Name:    "users",
		Columns: columns,
	}
	
	tests := []struct {
		name           string
		action         string
		rows           [][]interface{}
		expectedEvents int
		expectedAction string
	}{
		{
			name:   "insert event",
			action: canal.InsertAction,
			rows: [][]interface{}{
				{1, "John Doe", "john@example.com"},
			},
			expectedEvents: 1,
			expectedAction: "insert",
		},
		{
			name:   "delete event",
			action: canal.DeleteAction,
			rows: [][]interface{}{
				{1, "John Doe", "john@example.com"},
			},
			expectedEvents: 1,
			expectedAction: "delete",
		},
		{
			name:   "update event",
			action: canal.UpdateAction,
			rows: [][]interface{}{
				{1, "John Doe", "john@example.com"},        // old row
				{1, "John Smith", "johnsmith@example.com"}, // new row
			},
			expectedEvents: 1,
			expectedAction: "update",
		},
		{
			name:   "multiple insert events",
			action: canal.InsertAction,
			rows: [][]interface{}{
				{1, "John Doe", "john@example.com"},
				{2, "Jane Doe", "jane@example.com"},
			},
			expectedEvents: 2,
			expectedAction: "insert",
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Reset mock sender
			mockSender.events = make([]events.RecordEvent, 0)
			
			// Create rows event
			rowsEvent := &canal.RowsEvent{
				Table:  table,
				Action: tt.action,
				Rows:   tt.rows,
				Header: &replication.EventHeader{
					LogPos: mysql.Position{Name: "mysql-bin.000001", Pos: 1000},
				},
			}
			
			// Test
			err := handler.OnRow(rowsEvent)
			
			// Verify
			require.NoError(t, err)
			
			// Wait for events to be processed
			assert.True(t, mockSender.WaitForEvents(tt.expectedEvents, 1*time.Second))
			
			events := mockSender.GetEvents()
			assert.Len(t, events, tt.expectedEvents)
			
			for _, event := range events {
				assert.Equal(t, tt.expectedAction, event.Action)
				assert.Equal(t, "testdb", event.Schema)
				assert.Equal(t, "users", event.Collection)
				assert.NotEmpty(t, event.Data)
				
				// Verify data can be unmarshaled
				var data map[string]interface{}
				err := json.Unmarshal(event.Data, &data)
				require.NoError(t, err)
				
				// For update events, verify old data exists
				if tt.expectedAction == "update" {
					assert.NotEmpty(t, event.OldData)
					var oldData map[string]interface{}
					err := json.Unmarshal(event.OldData, &oldData)
					require.NoError(t, err)
				}
			}
		})
	}
}

func TestMySQLEventHandler_OnRotate(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	handler := &MySQLEventHandler{provider: provider}
	
	rotateEvent := &replication.RotateEvent{
		NextLogName: []byte("mysql-bin.000002"),
		Position:    2000,
	}
	
	err := handler.OnRotate(rotateEvent)
	require.NoError(t, err)
	
	expectedPos := mysql.Position{
		Name: "mysql-bin.000002",
		Pos:  2000,
	}
	
	assert.Equal(t, expectedPos, provider.lastPosition)
}

func TestMySQLEventHandler_OnDDL(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	handler := &MySQLEventHandler{provider: provider}
	
	nextPos := mysql.Position{Name: "mysql-bin.000001", Pos: 1500}
	queryEvent := &replication.QueryEvent{
		Schema: []byte("testdb"),
		Query:  []byte("ALTER TABLE users ADD COLUMN age INT"),
	}
	
	err := handler.OnDDL(nextPos, queryEvent)
	require.NoError(t, err)
	
	assert.Equal(t, nextPos, provider.lastPosition)
}

func TestMySQLEventHandler_OnXID(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	handler := &MySQLEventHandler{provider: provider}
	
	nextPos := mysql.Position{Name: "mysql-bin.000001", Pos: 2000}
	
	err := handler.OnXID(nextPos)
	require.NoError(t, err)
	
	assert.Equal(t, nextPos, provider.lastPosition)
}

func TestMySQLEventHandler_OnGTID(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	handler := &MySQLEventHandler{provider: provider}
	
	// Create a mock GTID set
	gtidSet, err := mysql.ParseGTIDSet(mysql.MySQLFlavor, "de278ad0-2106-11e4-9f8e-6edd0ca20947:1-100")
	require.NoError(t, err)
	
	err = handler.OnGTID(gtidSet)
	require.NoError(t, err)
}

func TestMySQLEventHandler_String(t *testing.T) {
	handler := &MySQLEventHandler{}
	assert.Equal(t, "MySQLEventHandler", handler.String())
}

func TestMySQLStreamProvider_Stop(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	provider.isRunning = true
	
	// Test stop when running
	provider.Stop()
	
	// Verify stop channel is closed (would cause panic if called again)
	// We can't directly test channel closure, but we can test that isRunning is false
	assert.False(t, provider.isRunning)
}

func TestMySQLStreamProvider_GetLastPosition(t *testing.T) {
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	
	expectedPos := mysql.Position{Name: "mysql-bin.000001", Pos: 1000}
	provider.lastPosition = expectedPos
	
	pos := provider.GetLastPosition()
	assert.Equal(t, expectedPos, pos)
}

// Integration test that requires actual MySQL server
func TestMySQLStreamProvider_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}
	
	// This test would require a real MySQL server with binlog enabled
	// It's marked to skip in normal test runs but can be enabled for integration testing
	t.Skip("Integration test requires MySQL server setup")
	
	// Example integration test setup:
	/*
	// Setup global config
	config.Global = &config.WaterFlowsStruct{
		MyDBUser:   "root",
		MyDBPasswd: "password",
		WaterFlowsConfig: &config.WaterFlowsConfig{
			Type:   "mysql",
			Host:   "localhost",
			Port:   3306,
			Schema: "testdb",
		},
	}
	
	mockSender := NewMockEventSender()
	defer mockSender.Close()
	
	logger := logrus.New()
	logger.SetLevel(logrus.DebugLevel)
	
	provider := NewMySQLStreamProvider(mockSender.GetChannel(), logger)
	
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	// Start listening in goroutine
	errChan := make(chan error, 1)
	go func() {
		errChan <- provider.Listen(ctx)
	}()
	
	// Wait a bit for connection to establish
	time.Sleep(2 * time.Second)
	
	// Perform some database operations here to generate events
	// ...
	
	// Stop the provider
	provider.Stop()
	
	// Wait for completion
	select {
	case err := <-errChan:
		if err != context.Canceled {
			t.Errorf("Unexpected error: %v", err)
		}
	case <-time.After(5 * time.Second):
		t.Error("Provider did not stop within timeout")
	}
	
	// Verify events were captured
	events := mockSender.GetEvents()
	// Add assertions based on the operations performed
	*/
}
